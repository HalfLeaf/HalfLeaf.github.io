"use strict";
const sitemap_1 = require("sitemap");
const chalk_1 = require("chalk");
const fs_1 = require("fs");
const path_1 = require("path");
const log = (msg, color = "cyan", label = "Sitemap") => console.log(`\n${chalk_1.default[color](`${label}: `)}${msg}`);
const stripLocalePrefix = (path, localePathPrefixes) => {
    const matchingPrefix = localePathPrefixes
        .filter((prefix) => path.startsWith(prefix))
        .shift();
    return {
        normalizedPath: path.replace(matchingPrefix, "/"),
        localePrefix: matchingPrefix,
    };
};
const generatePageMap = (siteData, base, options) => {
    const { changefreq = "daily", exclude = [], dateFormatter = (page) => page.lastUpdatedTime ? new Date(page.lastUpdatedTime).toISOString() : "", } = options;
    const { pages, locales = {} } = siteData;
    // Sort the locale keys in reverse order so that longer locales, such as '/en/', match before the default '/'
    const localeKeys = Object.keys(locales).sort().reverse() || [];
    const localesByNormalizedPagePath = pages.reduce((map, page) => {
        const { normalizedPath, localePrefix } = stripLocalePrefix(page.path, localeKeys);
        const prefixesByPath = map.get(normalizedPath) || [];
        prefixesByPath.push(localePrefix);
        return map.set(normalizedPath, prefixesByPath);
    }, new Map());
    const pagesMap = new Map();
    pages.forEach((page) => {
        const frontmatterOptions = page.frontmatter.sitemap || {};
        const metaRobots = (page.frontmatter.meta || []).find((meta) => meta.name === "robots");
        const excludePage = metaRobots
            ? (metaRobots.content || "")
                .split(/,/u)
                .map((content) => content.trim())
                .includes("noindex")
            : frontmatterOptions.exclude;
        if (excludePage)
            exclude.push(page.path);
        const lastmodifyTime = dateFormatter(page);
        const { normalizedPath } = stripLocalePrefix(page.path, localeKeys);
        const relatedLocales = localesByNormalizedPagePath.get(normalizedPath) || [];
        let links = [];
        if (relatedLocales.length > 1)
            links = relatedLocales.map((localePrefix) => ({
                lang: locales[localePrefix].lang || "en",
                url: `${base}${normalizedPath.replace("/", localePrefix)}`,
            }));
        pagesMap.set(page.path, Object.assign(Object.assign({}, frontmatterOptions), { changefreq: frontmatterOptions.changefreq || changefreq, lastmod: lastmodifyTime, links }));
    });
    return pagesMap;
};
const generateSiteMap = (siteData, { outDir, themeConfig }, options) => {
    log("Generating sitemap...");
    const { urls = [], hostname, outFile = "sitemap.xml", xslUrl, exclude = [], xmlNameSpace: xmlns, } = options;
    const sitemap = new sitemap_1.SitemapStream({
        hostname: hostname || themeConfig.hostname,
        xslUrl,
        xmlns,
    });
    const sitemapXML = path_1.resolve(outDir, outFile);
    const writeStream = fs_1.createWriteStream(sitemapXML);
    sitemap.pipe(writeStream);
    const base = siteData.base.replace(/\/$/u, "");
    const pagesMap = generatePageMap(siteData, base, options);
    pagesMap.forEach((page, url) => {
        if (!exclude.includes(url))
            sitemap.write(Object.assign({ url: `${base}${url}` }, page));
    });
    urls.forEach((item) => sitemap.write(item));
    sitemap.end();
    log("Sitemap generated.");
};
module.exports = (options, context) => ({
    name: "sitemap",
    generated() {
        const hostname = options.hostname || context.themeConfig.hostname;
        if (hostname)
            generateSiteMap(context.getSiteData(), context, options);
        else
            log('Not generating sitemap because required "hostname" option doesn\'t exist', "red");
    },
    plugins: ["@mr-hope/last-update", ["@vuepress/last-updated", false]],
});
